## Shell Tools

Use shell for: (a) package install/build/test/git, (b) OS-level operations not possible with file tools (chmod, symlink).
For file read/write/search, ALWAYS use dedicated tools instead.

### shell_execute
**Purpose**: Run shell commands with configurable timeout (default: 10s)

**When to use**:
- Package management: `npm install`, `pip install`, `cargo build`
- Version control: `git status`, `git commit`, `git push`
- Build systems: `make`, `npm run build`, `docker build`
- Running tests: `npm test`, `pytest`, `cargo test`
- OS-level only: `chmod`, `ln -s`, `chown` (use file tools for mkdir - write_file auto-creates parent dirs)

**Timeout guidelines**:
- Quick commands (git status, whoami, pwd): default 10s is fine
- Package install (npm install, pip install): use `timeout_ms: 120000` (2 min)
- Build commands (npm run build, cargo build): use `timeout_ms: 300000` (5 min)
- Test suites (npm test, pytest): use `timeout_ms: 300000` (5 min)
- Model downloads, large operations: use `timeout_ms: 600000` (10 min)

**On timeout or interactive state**:
- `[TIMEOUT]`: Process may still be running. Check terminal screen for status.
- `[ERROR] Command blocked - terminal entered interactive state`: Terminal has a foreground process.
  - **IMMEDIATE ACTION REQUIRED**: Use `shell_interact` to handle before ANY other shell commands
  - DO NOT ignore this error and continue with other tools
  - Common actions: `shell_interact('<Ctrl+C>')` to interrupt, or send appropriate response

**Automatic non-interactive mode**:
Commands are automatically wrapped with non-interactive flags when possible:
- apt/apt-get: `DEBIAN_FRONTEND=noninteractive` + `-y` flag
- git clone/fetch/pull/push: `GIT_TERMINAL_PROMPT=0` + SSH BatchMode
- npm/yarn/pnpm/bun install: `CI=true` environment
- pip install: `PIP_NO_INPUT=1`
- yum/dnf: `-y` flag, pacman: `--noconfirm` flag
- brew: `NONINTERACTIVE=1`, terraform: `-auto-approve` flag

**Background processes**:
- Commands ending with `&` run in background
- ALWAYS verify after starting:
  ```
  shell_execute("nohup python app.py > server.log 2>&1 &")
  shell_execute("sleep 2")  # Give it time to start
  shell_execute("curl http://localhost:5000/health")  # Verify
  ```
- If verification fails:
  - Check logs: `read_file("server.log")`
  - Check process: `shell_execute("ps aux | grep app.py")`
  - Check port: `shell_execute("lsof -i :5000")`

### shell_interact
**Purpose**: Send raw keystrokes to the terminal (for interactive programs)

**When to use**:
- **REQUIRED** after interactive state error - respond IMMEDIATELY before any other commands
- Responding to prompts (y/n questions, config conflicts)
- Recovering from timeouts (send `<Ctrl+C>`)
- Navigating interactive programs (vim, less, pagers)

**Key points**:
- Must include `<Enter>` to execute commands
- Shares the SAME persistent terminal session with `shell_execute`
- If response shows `[SYSTEM REMINDER] Terminal is in interactive state`, continue using shell_interact

**Common responses**:
```
shell_interact("<Ctrl+C>")     # Interrupt/cancel current process
shell_interact("q")            # Quit pagers (less, more, git diff)
shell_interact(":q!<Enter>")   # Force quit vim
shell_interact("y<Enter>")     # Answer yes
shell_interact("n<Enter>")     # Answer no
shell_interact("<Enter>")      # Accept default / continue
```

### Tool Selection Rules (STRICT)

**NEVER use shell for these - use dedicated tools**:

| Task | Forbidden Shell | Required Tool |
|------|-----------------|---------------|
| Read file contents | `cat`, `head`, `tail` | `read_file` |
| Modify file contents | `sed`, `awk`, `perl -i` | `edit_file` |
| Create/overwrite file | `echo >`, `cat <<EOF` | `write_file` |
| Delete file/directory | `rm`, `rm -rf` | `delete_file` |
| Search file contents | `grep`, `rg`, `ag` | `grep` tool |
| Find files by pattern | `find`, `ls`, `tree` | `glob` tool |

**Why dedicated tools?**
- Safer: No shell escaping issues, no injection risks
- Reliable: No platform differences (macOS vs Linux)
- Better errors: Clear messages instead of cryptic shell errors

### File Safety Rules

**Before overwriting existing files with write_file**:
- Read the file first to understand current contents
- Confirm with user if changes are significant or destructive

**Before using delete_file**:
- Verify path exists with `glob` or `read_file`
- Confirm deletion is intended (especially for directories with recursive: true)

### Common Workflow: grep â†’ read_file

```
# Step 1: Find where function is defined
grep("process_data", include="**/*.py")
# Returns: src/utils.py:42: def process_data(items):

# Step 2: Read surrounding context
read_file("src/utils.py", offset=35, limit=30)  # Lines 35-65
```

### Error Recovery

| Error | Cause | Solution |
|-------|-------|----------|
| `Command blocked - interactive state` | Previous command waiting for input | Use `shell_interact` immediately |
| `[TIMEOUT]` with process still running | Command exceeded timeout | Increase `timeout_ms` or use `shell_interact('<Ctrl+C>')` |
| Service not responding after background start | Service failed to start | Check logs, verify with curl/health check |
